---
- name: Validate required variables
  ansible.builtin.assert:
    that:
      - update_compose_remote_path is defined
      - template_file_name is defined
      - update_compose_project_path is defined
    fail_msg: "Missing required variables: update_compose_remote_path, template_file_name, update_compose_project_path"

- name: Set default values for optional variables
  ansible.builtin.set_fact:
    max_backups: "{{ max_backups | default(3) }}"
    validate_compose: "{{ validate_compose | default(true) }}"
    cleanup_resources: "{{ cleanup_resources | default(true) }}"
    pull_retries: "{{ pull_retries | default(5) }}"
    pull_delay: "{{ pull_delay | default(20) }}"

- name: Check remote docker-compose file
  ansible.builtin.stat:
    path: "{{ update_compose_remote_path }}"
  register: remote_file

- name: Read remote file content if exists
  ansible.builtin.slurp:
    src: "{{ update_compose_remote_path }}"
  register: remote_file_content
  when: remote_file.stat.exists

- name: Render template content
  ansible.builtin.set_fact:
    template_file_rendered: "{{ lookup('template', template_file_name) }}"

- name: Compare template with remote content
  ansible.builtin.set_fact:
    contents_different: >-
      {{ not remote_file.stat.exists or 
         ((remote_file_content.content | b64decode).strip() != template_file_rendered.strip()) }}

- name: Determine if update is needed
  ansible.builtin.set_fact:
    should_update: "{{ force_update | default(false) | bool or contents_different }}"

- name: Display update decision
  ansible.builtin.debug:
     msg: "Files diversi: {{ contents_different }}. Aggiornamento forzato: {{ force_update | default(false) | bool }}. Procedo con l'aggiornamento: {{ should_update }}"

- name: Execute Docker operations if update needed
  when: should_update
  block:
    # Gestione backup limitata
    - name: Gestisci file di backup
      when: remote_file.stat.exists and contents_different
      block:
        - name: Trova file backup esistenti
          ansible.builtin.find:
            paths: "{{ update_compose_remote_path | dirname }}"
            patterns: "{{ update_compose_remote_path | basename }}.*.backup"
            file_type: file
          register: existing_backups

        - name: Ordina backup per data (più vecchi primi)
          ansible.builtin.set_fact:
            sorted_backups: "{{ existing_backups.files | sort(attribute='mtime') }}"

        - name: Rimuovi backup in eccesso
          ansible.builtin.file:
            path: "{{ item.path }}"
            state: absent
          loop: "{{ sorted_backups[:(sorted_backups | length - max_backups + 1)] }}"
          when: sorted_backups | length >= max_backups

    # Validazione template
    - name: Valida nuovo template docker-compose
      when: contents_different and validate_compose
      block:
        - name: Crea file temporaneo per validazione
          ansible.builtin.set_fact:
            temp_compose_file: "{{ update_compose_remote_path }}.tmp.{{ ansible_date_time.epoch }}"

        - name: Applica template in posizione temporanea
          ansible.builtin.template:
            src: "{{ template_file_name }}"
            dest: "{{ temp_compose_file }}"
            mode: '0644'

        - name: Valida sintassi docker-compose
          ansible.builtin.command:
            cmd: "docker compose -f {{ temp_compose_file }} config"
            chdir: "{{ update_compose_project_path }}"
          register: compose_validation
          failed_when: compose_validation.rc != 0
          changed_when: false

        - name: Rimuovi file temporaneo
          ansible.builtin.file:
            path: "{{ temp_compose_file }}"
            state: absent

    - name: Stop existing containers
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: absent
      when: remote_file.stat.exists
      register: compose_down_result
      failed_when: false  # Don't fail if containers are already stopped

    - name: Deploy docker-compose template if needed
      ansible.builtin.template:
        src: "{{ template_file_name }}"
        dest: "{{ update_compose_remote_path }}"
        mode: '0644'
        backup: yes
        backup_file: "{{ update_compose_remote_path }}.{{ ansible_date_time.epoch }}.backup"
      when: contents_different

    - name: Pull Docker images with retry
      community.docker.docker_compose_v2_pull:
        project_src: "{{ update_compose_project_path }}"
      register: pull_result
      retries: "{{ pull_retries }}"
      delay: "{{ pull_delay }}"
      until: not pull_result.failed

    - name: Start containers
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: present
      register: compose_up_result

    # Pulizia risorse Docker
    - name: Pulisci risorse Docker inutilizzate
      when: cleanup_resources and compose_up_result is succeeded
      block:
        - name: Rimuovi immagini Docker inutilizzate
          community.docker.docker_prune:
            images: true
            images_filters:
              dangling: false
          register: prune_images_result
          failed_when: false

        - name: Rimuovi volumi Docker inutilizzati
          community.docker.docker_prune:
            volumes: true
          register: prune_volumes_result
          failed_when: false

        - name: Rimuovi reti Docker inutilizzate
          community.docker.docker_prune:
            networks: true
          register: prune_networks_result
          failed_when: false

        - name: Mostra risultati pulizia
          ansible.builtin.debug:
            msg: >-
              Pulizia completata - 
              Immagini: {{ prune_images_result.images_deleted | default([]) | length }} rimosse, 
              Volumi: {{ prune_volumes_result.volumes_deleted | default([]) | length }} rimossi, 
              Reti: {{ prune_networks_result.networks_deleted | default([]) | length }} rimosse

- name: Report no update needed
  ansible.builtin.debug:
    msg: "Nessun aggiornamento necessario. I contenuti sono identici e force_update è false."
  when: not should_update
