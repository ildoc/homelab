---
- name: Validate required variables
  ansible.builtin.assert:
    that:
      - update_compose_remote_path is defined
      - template_file_name is defined
      - update_compose_project_path is defined
    fail_msg: "Missing required variables: update_compose_remote_path, template_file_name, update_compose_project_path"

- name: Set default values for optional variables
  ansible.builtin.set_fact:
    max_backups: "{{ max_backups | default(3) }}"
    validate_compose: "{{ validate_compose | default(true) }}"
    cleanup_resources: "{{ cleanup_resources | default(true) }}"
    pull_retries: "{{ pull_retries | default(5) }}"
    pull_delay: "{{ pull_delay | default(20) }}"

- name: Check remote docker-compose file
  ansible.builtin.stat:
    path: "{{ update_compose_remote_path }}"
  register: remote_file

- name: Read remote file content if exists
  ansible.builtin.slurp:
    src: "{{ update_compose_remote_path }}"
  register: remote_file_content
  when: remote_file.stat.exists

- name: Render template content
  ansible.builtin.set_fact:
    template_file_rendered: "{{ lookup('template', template_file_name) }}"

- name: Compare template with remote content
  ansible.builtin.set_fact:
    contents_different: >-
      {{ not remote_file.stat.exists or 
         ((remote_file_content.content | b64decode).strip() != template_file_rendered.strip()) }}

- name: Determine if update is needed
  ansible.builtin.set_fact:
    should_update: "{{ force_update | default(false) | bool or contents_different }}"

- name: Display update decision
  ansible.builtin.debug:
     msg: "Files different: {{ contents_different }}. Force update: {{ force_update | default(false) | bool }}. Proceeding with update: {{ should_update }}"

- name: Execute Docker operations if update needed
  when: should_update
  block:
    # Limited backup management
    - name: Manage backup files
      when: remote_file.stat.exists and contents_different
      block:
        - name: Find existing backup files
          ansible.builtin.find:
            paths: "{{ update_compose_remote_path | dirname }}"
            patterns: "{{ update_compose_remote_path | basename }}.*~"
            file_type: file
          register: existing_backups

        - name: Sort backups by date (oldest first)
          ansible.builtin.set_fact:
            sorted_backups: "{{ existing_backups.files | sort(attribute='mtime') }}"

        - name: Remove excess backup files
          ansible.builtin.file:
            path: "{{ item.path }}"
            state: absent
          loop: "{{ sorted_backups[:(sorted_backups | length - max_backups + 1)] }}"
          when: sorted_backups | length >= max_backups

    # Template validation
    - name: Validate new docker-compose template
      when: contents_different and validate_compose
      block:
        - name: Create temporary file for validation
          ansible.builtin.set_fact:
            temp_compose_file: "{{ update_compose_remote_path }}.tmp.{{ ansible_date_time.epoch }}"

        - name: Apply template to temporary location
          ansible.builtin.template:
            src: "{{ template_file_name }}"
            dest: "{{ temp_compose_file }}"
            mode: '0644'

        - name: Validate docker-compose syntax
          ansible.builtin.command:
            cmd: "docker compose -f {{ temp_compose_file }} config"
            chdir: "{{ update_compose_project_path }}"
          register: compose_validation
          failed_when: compose_validation.rc != 0
          changed_when: false

        - name: Remove temporary file
          ansible.builtin.file:
            path: "{{ temp_compose_file }}"
            state: absent

    - name: Stop existing containers
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: absent
      when: remote_file.stat.exists
      register: compose_down_result
      failed_when: false  # Don't fail if containers are already stopped

    - name: Deploy docker-compose template if needed
      ansible.builtin.template:
        src: "{{ template_file_name }}"
        dest: "{{ update_compose_remote_path }}"
        mode: '0644'
        backup: yes
      when: contents_different

    - name: Pull Docker images with retry
      community.docker.docker_compose_v2_pull:
        project_src: "{{ update_compose_project_path }}"
      register: pull_result
      retries: "{{ pull_retries }}"
      delay: "{{ pull_delay }}"
      until: not pull_result.failed

    - name: Start containers
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: present
      register: compose_up_result

    # Docker resources cleanup
    - name: Clean up unused Docker resources
      when: cleanup_resources and compose_up_result is succeeded
      block:
        - name: Remove unused Docker images
          community.docker.docker_prune:
            images: true
            images_filters:
              dangling: false
          register: prune_images_result
          failed_when: false

        - name: Remove unused Docker volumes
          community.docker.docker_prune:
            volumes: true
          register: prune_volumes_result
          failed_when: false

        - name: Remove unused Docker networks
          community.docker.docker_prune:
            networks: true
          register: prune_networks_result
          failed_when: false

        - name: Display cleanup results
          ansible.builtin.debug:
            msg: >-
              Cleanup completed - 
              Images: {{ prune_images_result.images_deleted | default([]) | length }} removed, 
              Volumes: {{ prune_volumes_result.volumes_deleted | default([]) | length }} removed, 
              Networks: {{ prune_networks_result.networks_deleted | default([]) | length }} removed

- name: Report no update needed
  ansible.builtin.debug:
    msg: "No update needed. Contents are identical and force_update is false."
  when: not should_update
