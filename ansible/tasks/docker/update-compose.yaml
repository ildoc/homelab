---
- name: Validate required variables
  ansible.builtin.assert:
    that:
      - update_compose_remote_path is defined
      - update_compose_local_path is defined
      - update_compose_project_path is defined
    fail_msg: "Missing required variables: update_compose_remote_path, update_compose_local_path, update_compose_project_path"

- name: Set default values for optional variables
  ansible.builtin.set_fact:
    max_backups: "{{ max_backups | default(3) }}"
    validate_compose: "{{ validate_compose | default(true) }}"
    cleanup_resources: "{{ cleanup_resources | default(true) }}"

- name: Check remote docker-compose file
  ansible.builtin.stat:
    path: "{{ update_compose_remote_path }}"
  register: remote_file

- name: Check local docker-compose file
  ansible.builtin.stat:
    path: "{{ update_compose_local_path }}"
  register: local_file
  delegate_to: localhost

- name: Validate local file exists
  ansible.builtin.assert:
    that: local_file.stat.exists
    fail_msg: "Local file {{ update_compose_local_path }} does not exist"

- name: Controlla differenze tra file e imposta variabili
  ansible.builtin.set_fact:
    contents_different: "{{ not remote_file.stat.exists or (remote_file.stat.checksum != local_file.stat.checksum) }}"

- name: Determina se è necessario l'aggiornamento
  ansible.builtin.set_fact:
    should_update: "{{ force_update | default(false) | bool or contents_different }}"

- name: Mostra stato dell'aggiornamento
  ansible.builtin.debug:
    msg: "Files diversi: {{ contents_different }}. Aggiornamento forzato: {{ force_update | default(false) | bool }}. Procedo con l'aggiornamento: {{ should_update }}"

- name: Esegui azioni Docker se necessario l'aggiornamento
  when: should_update
  block:
    # Gestione backup limitata
    - name: Gestisci file di backup
      when: remote_file.stat.exists and contents_different
      block:
        - name: Trova file backup esistenti
          ansible.builtin.find:
            paths: "{{ update_compose_remote_path | dirname }}"
            patterns: "{{ update_compose_remote_path | basename }}.*.backup"
            file_type: file
          register: existing_backups

        - name: Ordina backup per data (più vecchi primi)
          ansible.builtin.set_fact:
            sorted_backups: "{{ existing_backups.files | sort(attribute='mtime') }}"

        - name: Rimuovi backup in eccesso
          ansible.builtin.file:
            path: "{{ item.path }}"
            state: absent
          loop: "{{ sorted_backups[:(sorted_backups | length - max_backups + 1)] }}"
          when: sorted_backups | length >= max_backups

    # Validazione docker-compose
    - name: Valida nuovo docker-compose
      when: contents_different and validate_compose
      block:
        - name: Crea file temporaneo per validazione
          ansible.builtin.set_fact:
            temp_compose_file: "{{ update_compose_remote_path }}.tmp.{{ ansible_date_time.epoch }}"

        - name: Copia file in posizione temporanea
          ansible.builtin.copy:
            src: "{{ update_compose_local_path }}"
            dest: "{{ temp_compose_file }}"
            mode: '0644'

        - name: Valida sintassi docker-compose
          ansible.builtin.command:
            cmd: "docker compose -f {{ temp_compose_file }} config"
            chdir: "{{ update_compose_project_path }}"
          register: compose_validation
          failed_when: compose_validation.rc != 0
          changed_when: false

        - name: Rimuovi file temporaneo
          ansible.builtin.file:
            path: "{{ temp_compose_file }}"
            state: absent

    - name: Ferma i container esistenti
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: absent
      when: remote_file.stat.exists
      register: compose_down_result
      failed_when: false  # Non fallire se i container sono già fermi

    - name: Copia il file docker-compose.yml se necessario
      ansible.builtin.copy:
        src: "{{ update_compose_local_path }}"
        dest: "{{ update_compose_remote_path }}"
        mode: '0644'
        backup: yes
        backup_file: "{{ update_compose_remote_path }}.{{ ansible_date_time.epoch }}.backup"
      when: contents_different

    - name: Esegui docker-compose pull con retry
      community.docker.docker_compose_v2_pull:
        project_src: "{{ update_compose_project_path }}"
      register: pull_result
      retries: 3
      delay: 10
      until: not pull_result.failed

    - name: Avvia i container
      community.docker.docker_compose_v2:
        project_src: "{{ update_compose_project_path }}"
        state: present
      register: compose_up_result

    # Pulizia risorse Docker
    - name: Pulisci risorse Docker inutilizzate
      when: cleanup_resources and compose_up_result is succeeded
      block:
        - name: Rimuovi immagini Docker inutilizzate
          community.docker.docker_prune:
            images: true
            images_filters:
              dangling: false
          register: prune_images_result
          failed_when: false

        - name: Rimuovi volumi Docker inutilizzati
          community.docker.docker_prune:
            volumes: true
          register: prune_volumes_result
          failed_when: false

        - name: Rimuovi reti Docker inutilizzate
          community.docker.docker_prune:
            networks: true
          register: prune_networks_result
          failed_when: false

        - name: Mostra risultati pulizia
          ansible.builtin.debug:
            msg: >-
              Pulizia completata - 
              Immagini: {{ prune_images_result.images_deleted | default([]) | length }} rimosse, 
              Volumi: {{ prune_volumes_result.volumes_deleted | default([]) | length }} rimossi, 
              Reti: {{ prune_networks_result.networks_deleted | default([]) | length }} rimosse

- name: Nessun aggiornamento necessario
  ansible.builtin.debug:
    msg: "Nessun aggiornamento necessario. I file sono identici e force_update è false."
  when: not should_update
