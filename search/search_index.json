{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Homelab","text":"<p>Questo progetto mira a utilizzare Infrastructure as Code e GitOps per automatizzare il pi\u00f9 possibile l'installazione e la configurazione del software che gira sul mio Homelab.</p> <p>Nel 2020 sono partito da un docker-compose e oggi sono messo cos\u00ec... \u00e8 un work in progress continuo \ud83d\ude05</p> <p>Che cos'\u00e8 un homelab?</p> <p>Un Homelab \u00e8 un laboratorio casalingo dove si pu\u00f2 fare self-hosting, sperimentare nuove tecnologie, fare pratica per certificazioni e cos\u00ec via.</p> <p>Per maggiori informazioni fare riferimento alla introduzione di r/homelab e alla community Discord Home Operations (ex k8s-at-home).</p> <p>Un ottimo articolo \u00e8 anche What is a Homelab and Why Should You Have One? </p>"},{"location":"#overview-generale","title":"Overview generale","text":"<p>Tutto l'Homelab gestito (principalmente) con playbook Ansible, ArgoCD e pipeline Gitlab.</p> <p>NOTA: questo repository GitHub \u00e8 un mirror del repository originale che si trova sulla mia istanza privata di GitLab</p>"},{"location":"#tech-stack","title":"Tech stack","text":"Logo Nome Descrzione Ansible Automazione di deploy e configurazioni ArgoCD Tool GitOps per deployare su Kubernetes Backblaze B2 Backup cloud di Truenas su bucket s3 cert-manager Cloud native certificate management Cilium CNI e controller per Gateway API Cloudflare Issuer dei certificati e Tunnel Docker Orchestrazione di container con docker compose GitLab Self-hosted Git e runner di pipeline CI/CD HashiCorp Vault Secrets management Helm Package manager per Kubernetes kube-vip Virtual IP e load balancer Kubernetes Container-orchestration system NGINX Reverse Proxy per GitLab OpenTofu Infrastructure as Code (work in progress) Pi-hole Ad blocker, DNS e DHCP Proxmox Virtualizzazione di VM e LXC Renovate Update automatico delle dipendenze TrueNAS NFS share, Backup Ubuntu Server Os di base per i nodi Kubernetes Wireguard VPN tunnel"},{"location":"hardware/","title":"Hardware","text":""},{"location":"hardware/#cluster-proxmox","title":"Cluster Proxmox","text":"<p>3x Beelink EQR5</p> <ul> <li>AMD Ryzen 7 5825U</li> <li>500 GB SSD M.2 </li> <li>64GB Ram (2 x 32GB)</li> <li>1 TB SSD</li> </ul>"},{"location":"hardware/#truenas","title":"Truenas","text":"<ul> <li>AMD Ryzen 7 5825U</li> <li>64GB Ram (2 x 32GB)</li> <li>2x SSD 250GB in mirroring per il sistema operativo</li> <li>5x HDD 6TB in Raidz2 per i dati</li> <li>1x HDD 8TB per i media</li> <li>1x SSD Nvme 500GB per le applicazioni</li> </ul>"},{"location":"hardware/#varie-ed-eventuali","title":"Varie ed eventuali","text":"<ul> <li>Raspberry Pi Zero 2 con PiHole come DNS e DHCP di backup</li> <li>Nvidia Shield per riprodurre i media da Jellyfinn</li> <li>UPS Eaton 5E</li> </ul>"},{"location":"test/","title":"Test","text":"<p>Welcome to Material for MkDocs.</p>"},{"location":"test/#annotations","title":"Annotations","text":"<p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown.</li> </ol>"},{"location":"test/#in-admonitions","title":"in admonitions","text":"<p>Phasellus posuere in sem ut cursus (1)</p> <p>Lorem ipsum dolor sit amet, (2) consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <ol> <li> I'm an annotation!</li> <li> I'm an annotation as well!</li> </ol>"},{"location":"test/#blocco-espanso","title":"Blocco espanso","text":"Warning <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"test/#inline","title":"Inline","text":"<p>Lorem ipsum</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero lallallero </p> bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> <pre><code>theme:\n  features:\n    - content.code.annotate # (1)\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</li> </ol> .gitignore<pre><code># terraform\n**/.terraform\n**/.terraform.lock.hcl\n</code></pre> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> <p>Example</p> Unordered ListOrdered List <pre><code>* Sed sagittis eleifend rutrum\n* Donec vitae suscipit est\n* Nulla tempor lobortis orci\n</code></pre> <pre><code>1. Sed sagittis eleifend rutrum\n2. Donec vitae suscipit est\n3. Nulla tempor lobortis orci\n</code></pre> Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> Unordered listOrdered list <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ol> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ol> Content tabs<pre><code>=== \"Unordered list\"\n\n    * Sed sagittis eleifend rutrum\n    * Donec vitae suscipit est\n    * Nulla tempor lobortis orci\n\n=== \"Ordered list\"\n\n    1. Sed sagittis eleifend rutrum\n    2. Donec vitae suscipit est\n    3. Nulla tempor lobortis orci\n</code></pre> <ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> It's just Markdown</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Made to measure</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> <li> <p> Open Source, MIT</p> <p>Material for MkDocs is licensed under MIT and available on [GitHub]</p> <p> License</p> </li> </ul> <p> HTML for content and structure</p> <p> JavaScript for interactivity</p> <p> CSS for text running out of boxes</p> <p> Internet Explorer ... huh?</p> <p></p> <ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> <p> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</p> </li> <li> <p>Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis     sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis     nulla. Vivamus a pharetra leo.</p> <ol> <li> <p>Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet     quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a     ultricies libero efficitur sed.</p> </li> <li> <p>Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet     rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a.</p> <ol> <li>Mauris dictum mi lacus</li> <li>Ut sit amet placerat ante</li> <li>Suspendisse ac eros arcu</li> </ol> </li> </ol> </li> </ul>"},{"location":"ansible/vault/","title":"HashiCorp Vault","text":""},{"location":"blog/","title":"I miei post","text":""},{"location":"blog/2025/04/30/finalmente-open/","title":"Finalmente open!","text":"<p>Circa a maggio 2020 in mezzo ai lockdown del COVID ho iniziato a tirarmi su un mediaserver con un semplice docker-compose e oggi, dopo quasi 5 anni di smarmellamenti, ho deciso di provare a rendere pubblico il repository del mio homelab.</p> <p>Sostanzialmente \u00e8 diviso in due grosse parti:</p> <ul> <li>Ansible: per installare e configurare i servizi che stanno su delle VM o dei LXC sul cluster di Proxmox (Vault, Gitlab, PiHole)</li> <li>Kubernetes: con entrypoint root-applications.yaml gestito tutto in modalit\u00e0 Gitops tramite ArgoCD, sia la parte di infrastruttura (cert-manager, traefik, rancher), sia quella di applicazioni.</li> </ul> <p>Visto che avevo key e password versionate dappertutto, nelle ultime settimane ho provato a spostare tutto su Hashicorp Vault usando una immagine docker custom con vault-agent per poter lanciare i playbook Ansible che uso per deployare e configurare tutto.</p> <p>Su Kubernetes invece ho integrato External Secret Operator sempre per poter recuperare i secret dal Vault e mi sono \"divertito\" a trovare un modo per deployarlo e configurarlo in modalit\u00e0 GitOps con ArgoCD.</p> <p></p> <p>E' rimasto ancora qualcosa fuori, per cui per ora ho un job nel gitlab-ci di questo repository che d\u00e0 una ripulita prima di committare e pushare il tutto su un nuovo repo \"pulito\" che poi fa mirroring su Github.</p> <p>Come ultima novit\u00e0 ho introdotto MkDocs per cominciare a fare un po' di documentazione e gestire gli aggiornamenti di questo mini blog che verr\u00e0 pubblicato sulle Github Pages da una Github Action sul repository mirrorato.</p> <p>Di cose da fare ce ne sono un sacco...</p> <ul> <li>Voglio implementare Harbor per fare il caching delle immagini Docker di DockerHub in modo da non sforare i nuovi limiti di pull orari</li> <li>Vorrei approfondire Terraform/Opentofu per fare il provisioning delle vm su Proxmox in modo da poter collegare il tutto ai due playbook con cui faccio il setup del cluster Kubernetes e la sua configurazione iniziale</li> <li>Devo implementare il monitoring e le notifiche su tutti i servizi</li> <li>Vorrei un SSO centralizzato per tutto, tipo Autentik</li> <li>Mi piacerebbe scorporare dei roles Ansible per poterli distribuire in repository a s\u00e9 stanti</li> <li>Vorrei documentare bene il tutto e magari provare a scrivere degli altri post su questo blog relativamente a problemi con cui mi scontro o cose che provo</li> <li>Vorrei man mano pulire bene il repository, sistemare le sync wave e gli hook di argocd, rivedere i roles di ansible, fare il linting di tutti gli yaml</li> </ul> <p>Intanto rendere open questo repo \u00e8 stata una bella sfida, adesso avanti con i prossimi step!</p>","tags":["kubernetes","gitops"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/","title":"Mascherare WireGuard come HTTPS con sing-box: bypassare firewall aziendali","text":"<p>Ultimamente mi sono trovato spesso a lavorare da reti con firewall restrittivi che bloccano le VPN. Anche WireGuard, che di solito funziona bene, viene identificato e bloccato da molti firewall aziendali e sistemi DPI (Deep Packet Inspection).</p> <p>Ho deciso di risolvere il problema mascherando completamente il traffico UDP di WireGuard come traffico HTTPS reale su TCP/443, utilizzando sing-box con il protocollo VLESS + gRPC + TLS. Il risultato \u00e8 un tunnel VPN che appare come una normale connessione HTTPS a qualsiasi firewall o sistema di ispezione.</p> <p>Devo ammettere che senza l'ausilio di Claude e ChatGPT questa soluzione sarebbe stata molto pi\u00f9 difficile da trovare e implementare. Claude in particolare \u00e8 stato fondamentale nel debug di tutte le problematiche incontrate durante il setup, aiutandomi a risolvere errori di configurazione, problemi di routing e questioni relative alla sintassi di sing-box fino ad arrivare al flusso correttamente funzionante.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#il-problema","title":"Il problema","text":"<p>WireGuard utilizza UDP sulla porta 51820, e molti firewall aziendali bloccano questo tipo di traffico. Anche cambiando porta, il protocollo WireGuard pu\u00f2 essere facilmente identificato tramite DPI. La soluzione che ho implementato \u00e8 incapsulare tutto il traffico UDP dentro un tunnel TCP che sembri una normale connessione HTTPS.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#il-mio-setup","title":"Il mio setup","text":"<p>Ecco l'architettura che ho a disposizione:</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#hardware-e-infrastruttura","title":"Hardware e infrastruttura","text":"<ul> <li>Client: Beryl AX (router OpenWrt con architettura ARM64/aarch64) che uso come router portatile</li> <li>Server: Cluster Kubernetes con LoadBalancer (nel mio caso uso Cilium LB-IPAM, ma funziona anche con MetalLB)</li> <li>Gateway: UniFi Cloud Gateway (UCG) che funge da router principale e server WireGuard</li> <li>Router ISP: Router con port forwarding configurato</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#cosa-mi-serviva","title":"Cosa mi serviva","text":"<p>Per questo setup ho utilizzato:</p> <ol> <li>Un client con OpenWrt (nel mio caso un Beryl AX) dove installare sing-box</li> <li>Il mio cluster Kubernetes gi\u00e0 funzionante con:</li> <li>LoadBalancer configurato (uso Cilium LB-IPAM)</li> <li>cert-manager gi\u00e0 installato e configurato</li> <li>Un dominio pubblico con DNS configurato per puntare al mio IP pubblico</li> <li>Il mio server WireGuard gi\u00e0 configurato sull'UCG</li> <li>Accesso al router per configurare port forwarding</li> </ol>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#architettura-della-soluzione","title":"Architettura della soluzione","text":"<pre><code>graph TB\n    A[Beryl AX Client] --&gt;|WireGuard UDP| B[127.0.0.1:51820]\n    B --&gt;|sing-box client| C[vpn.mydomain.it:443&lt;br/&gt;VLESS/gRPC/TLS]\n    C --&gt;|HTTPS TCP 443| D[Internet]\n    D --&gt;|Port Forward| E[Router ISP&lt;br/&gt;443 TCP \u2192 UCG:39300]\n    E --&gt;|Port Forward| F[UCG&lt;br/&gt;39300 TCP \u2192 K8s LB:9443]\n    F --&gt;|LoadBalancer| G[Kubernetes Service&lt;br/&gt;sing-box:443]\n    G --&gt;|sing-box server| H[Decripta e forwarda&lt;br/&gt;UDP 51820]\n    H --&gt;|WireGuard UDP| I[WireGuard Server&lt;br/&gt;UCG]\n\n    style A fill:#1976d2,stroke:#0d47a1,stroke-width:2px,color:#fff\n    style I fill:#1976d2,stroke:#0d47a1,stroke-width:2px,color:#fff\n    style C fill:#f57c00,stroke:#e65100,stroke-width:2px,color:#fff\n    style G fill:#f57c00,stroke:#e65100,stroke-width:2px,color:#fff</code></pre> <p>Caratteristiche principali:</p> <ul> <li>TLS reale con certificato Let's Encrypt valido</li> <li>Protocollo gRPC (HTTP/2) con ALPN</li> <li>Traffico indistinguibile da HTTPS normale (browser-like)</li> <li>UDP di WireGuard completamente nascosto dentro TCP</li> <li>Bypass di firewall che bloccano VPN</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#parte-1-configurazione-client-beryl-ax-openwrt","title":"Parte 1 \u2013 Configurazione Client (Beryl AX / OpenWrt)","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#installazione-di-sing-box","title":"Installazione di sing-box","text":"<p>Ho installato sing-box sul Beryl AX (architettura aarch64 / arm64):</p> <pre><code>cd /tmp\nwget -O sing-box.tar.gz \\\n  https://github.com/SagerNet/sing-box/releases/download/v1.12.17/sing-box-1.12.17-linux-arm64.tar.gz\n\ntar xzf sing-box.tar.gz\nmv sing-box*/sing-box /usr/bin/sing-box\nchmod +x /usr/bin/sing-box\nrm -rf sing-box*\n</code></pre> <p>Ho verificato l'installazione:</p> <pre><code>sing-box version\n</code></pre> <p>Output: <code>sing-box version 1.12.17</code></p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#configurazione-del-client-sing-box","title":"Configurazione del client sing-box","text":"<p>Ho creato la directory di configurazione:</p> <pre><code>mkdir -p /etc/sing-box\n</code></pre> <p>Poi ho creato il file <code>/etc/sing-box/config.json</code>:</p> <pre><code>{\n  \"log\": {\n    \"level\": \"info\"\n  },\n  \"inbounds\": [\n    {\n      \"type\": \"direct\",\n      \"tag\": \"wg-in\",\n      \"listen\": \"127.0.0.1\",\n      \"listen_port\": 51820,\n      \"network\": \"udp\"\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"type\": \"vless\",\n      \"tag\": \"proxy\",\n      \"server\": \"vpn.mydomain.it\",\n      \"server_port\": 443,\n      \"uuid\": \"TUO-UUID-GENERATO\",\n      \"tls\": {\n        \"enabled\": true,\n        \"server_name\": \"vpn.mydomain.it\"\n      },\n      \"transport\": {\n        \"type\": \"grpc\",\n        \"service_name\": \"chrome\"\n      },\n      \"packet_encoding\": \"xudp\"\n    }\n  ],\n  \"route\": {\n    \"rules\": [\n      {\n        \"inbound\": \"wg-in\",\n        \"outbound\": \"proxy\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Ho generato un UUID v4 usando <code>uuidgen</code> che corrisponde a quello configurato sul server. Il <code>packet_encoding: \"xudp\"</code> \u00e8 essenziale per trasportare UDP su TCP in modo efficiente, mentre <code>listen: \"127.0.0.1\"</code> limita l'ascolto solo in locale.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#integrazione-con-openwrt-procd","title":"Integrazione con OpenWrt (procd)","text":"<p>Ho creato il service script <code>/etc/init.d/sing-box</code>:</p> <pre><code>#!/bin/sh /etc/rc.common\n\nSTART=95\nSTOP=10\nUSE_PROCD=1\n\nstart_service() {\n  procd_open_instance\n  procd_set_param command /usr/bin/sing-box run -c /etc/sing-box/config.json\n  procd_set_param respawn\n  procd_set_param stdout 1\n  procd_set_param stderr 1\n  procd_close_instance\n}\n</code></pre> <p>Ho abilitato e avviato il servizio:</p> <pre><code>chmod +x /etc/init.d/sing-box\n/etc/init.d/sing-box enable\n/etc/init.d/sing-box start\n</code></pre> <p>Per gestire il servizio uso i comandi standard di OpenWrt:</p> <pre><code>/etc/init.d/sing-box stop     # Ferma\n/etc/init.d/sing-box start    # Avvia\n/etc/init.d/sing-box restart  # Riavvia\n/etc/init.d/sing-box status   # Stato\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#configurazione-wireguard-sul-client","title":"Configurazione WireGuard sul client","text":"<p>Per massima flessibilit\u00e0, ho creato due profili WireGuard:</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#profilo-1-wireguard-direct-reti-normali","title":"Profilo 1: \"WireGuard Direct\" (reti normali)","text":"<p>Uso questo profilo quando sono su reti che non bloccano VPN:</p> <pre><code>[Interface]\nAddress = 10.20.0.4/32\nPrivateKey = TUA_CHIAVE_PRIVATA\nDNS = 192.168.0.5,192.168.0.6\nMTU = 1280\n\n[Peer]\nPublicKey = CHIAVE_PUBBLICA_SERVER\nAllowedIPs = 0.0.0.0/0\nEndpoint = vpn.mydomain.it:51820\nPersistentKeepalive = 25\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#profilo-2-wireguard-office-con-sing-box","title":"Profilo 2: \"WireGuard Office\" (con sing-box)","text":"<p>Uso questo profilo quando sono su reti restrittive (ufficio, hotel, ecc.):</p> <pre><code>[Interface]\nAddress = 10.20.0.4/32\nPrivateKey = TUA_CHIAVE_PRIVATA\nDNS = 192.168.0.5,192.168.0.6\nMTU = 1280\n\n[Peer]\nPublicKey = CHIAVE_PUBBLICA_SERVER\nAllowedIPs = 0.0.0.0/0\nEndpoint = 127.0.0.1:51820\nPersistentKeepalive = 25\n</code></pre> <p>La differenza chiave \u00e8 che l'endpoint punta a <code>127.0.0.1:51820</code> (sing-box locale) invece del server remoto.</p> <p>In pratica:</p> <ul> <li>Da casa/hotspot \u2192 uso il profilo \"Direct\"</li> <li>In ufficio/reti restrittive \u2192 uso il profilo \"Office\"</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#test-e-troubleshooting-client","title":"Test e troubleshooting client","text":"<p>Per validare la configurazione:</p> <pre><code>sing-box check -c /etc/sing-box/config.json\n</code></pre> <p>Per verificare che il listener UDP sia attivo:</p> <pre><code>netstat -lun | grep 51820\n</code></pre> <p>Output: <code>udp   0   0 127.0.0.1:51820   0.0.0.0:*</code></p> <p>Per verificare il processo:</p> <pre><code>ps | grep sing-box\n</code></pre> <p>Per i log in tempo reale:</p> <pre><code>logread -f | grep sing-box\n</code></pre> <p>Per testare la connessione WireGuard:</p> <pre><code>wg show\n</code></pre> <p>Output con handshake recente:</p> <pre><code>interface: wg0\n  latest handshake: 5 seconds ago\n  transfer: 1.2 KiB received, 892 B sent\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#parte-2-configurazione-server-kubernetes","title":"Parte 2 \u2013 Configurazione Server (Kubernetes)","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#prerequisiti","title":"Prerequisiti","text":"<p>Nel mio caso avevo gi\u00e0:</p> <ul> <li>Cluster Kubernetes funzionante</li> <li>cert-manager configurato con Let's Encrypt</li> <li>LoadBalancer funzionante (Cilium LB-IPAM)</li> <li>Accesso per creare risorse nel namespace <code>apps</code></li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#1-certificato-tls","title":"1. Certificato TLS","text":"<p>Ho creato il certificato TLS per il mio dominio:</p> <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: wg-domain-cert\n  namespace: apps\nspec:\n  secretName: wg-ildoc-it-tls\n  issuerRef:\n    name: letsencrypt-prod\n    kind: ClusterIssuer\n  dnsNames:\n    - vpn.mydomain.it\n</code></pre> <p>Ho verificato il certificato:</p> <pre><code>kubectl get certificate -n apps\nkubectl describe certificate wg-domain-cert -n apps\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#2-secret-uuid","title":"2. Secret UUID","text":"<p>Uso External Secrets Operator per gestire i secret da Vault. Il file completo \u00e8 disponibile nel repository:</p> <pre><code>---\napiVersion: external-secrets.io/v1\nkind: ExternalSecret\nmetadata:\n  name: vault-sing-box-secrets\n  namespace: apps\nspec:\n  refreshInterval: \"1h\"\n  secretStoreRef:\n    name: vault-kubernetes-secret-store\n    kind: ClusterSecretStore\n  target:\n    name: sing-box-secrets\n    creationPolicy: Owner\n  data:\n    - secretKey: client-uuid\n      remoteRef:\n        key: kubernetes/data/apps/sing-box\n        property: client_uuid\n    - secretKey: gateway-address\n      remoteRef:\n        key: kubernetes/data/apps/sing-box\n        property: gateway_address\n    - secretKey: gateway-port\n      remoteRef:\n        key: kubernetes/data/apps/sing-box\n        property: gateway_port\n</code></pre> <p>In alternativa, non usando External Secrets, si pu\u00f2 creare un Secret normale con l'UUID del client. L'UUID deve corrispondere esattamente a quello configurato sul client.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#3-configmap-configurazione-sing-box","title":"3. ConfigMap configurazione sing-box","text":"<p>Il ConfigMap completo \u00e8 disponibile nel repository:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: sing-box-config\n  namespace: apps\ndata:\n  config.json: |\n    {\n      \"log\": { \"level\": \"debug\" },\n      \"inbounds\": [\n        {\n          \"type\": \"vless\",\n          \"tag\": \"vless-in\",\n          \"listen\": \"::\",\n          \"listen_port\": 443,\n          \"users\": [\n            { \n              \"uuid\": \"UUID-CLIENT\"\n            }\n          ],\n          \"tls\": {\n            \"enabled\": true,\n            \"certificate_path\": \"/tls/tls.crt\",\n            \"key_path\": \"/tls/tls.key\"\n          },\n          \"transport\": {\n            \"type\": \"grpc\",\n            \"service_name\": \"chrome\"\n          }\n        }\n      ],\n      \"outbounds\": [\n        {\n          \"type\": \"direct\",\n          \"tag\": \"wg-out\"\n        }\n      ],\n      \"route\": {\n        \"rules\": [\n          {\n            \"inbound\": \"vless-in\",\n            \"action\": \"route-options\",\n            \"outbound\": \"wg-out\",\n            \"override_address\": \"GATEWAY-ADDRESS\",\n            \"override_port\": GATEWAY-PORT\n          }\n        ],\n        \"final\": \"wg-out\"\n      }\n    }\n</code></pre> <p>I placeholder <code>UUID-CLIENT</code>, <code>GATEWAY-ADDRESS</code> e <code>GATEWAY-PORT</code> vengono sostituiti dall'initContainer del deployment. Il <code>action: \"route-options\"</code> \u00e8 necessario dalla versione 1.11.0+ (nuova sintassi per override). Ho impostato il log level a <code>debug</code> per facilitare il troubleshooting, ma per produzione si pu\u00f2 cambiare in <code>info</code>.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#4-deployment-sing-box","title":"4. Deployment sing-box","text":"<p>Il deployment completo \u00e8 disponibile nel repository:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: sing-box\n  namespace: apps\nspec:\n  selector:\n    matchLabels:\n      app: sing-box\n  strategy:\n    type: Recreate\n  revisionHistoryLimit: 3\n  template:\n    metadata:\n      labels:\n        app: sing-box\n    spec:\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n        runAsGroup: 1000\n        fsGroup: 1000\n        seccompProfile:\n          type: RuntimeDefault\n      initContainers:\n        - name: config-generator\n          image: busybox:1.36\n          securityContext:\n            allowPrivilegeEscalation: false\n            runAsNonRoot: true\n            runAsUser: 1000\n            runAsGroup: 1000\n            capabilities:\n              drop:\n                - ALL\n          command:\n            - sh\n            - -c\n            - |\n              sed -e \"s/UUID-CLIENT/${CLIENT_UUID}/g\" \\\n                  -e \"s/GATEWAY-ADDRESS/${GATEWAY_ADDRESS}/g\" \\\n                  -e \"s/GATEWAY-PORT/${GATEWAY_PORT}/g\" \\\n                  /config-template/config.json &gt; /config/config.json\n          env:\n            - name: CLIENT_UUID\n              valueFrom:\n                secretKeyRef:\n                  name: sing-box-secrets\n                  key: client-uuid\n            - name: GATEWAY_ADDRESS\n              valueFrom:\n                secretKeyRef:\n                  name: sing-box-secrets\n                  key: gateway-address\n            - name: GATEWAY_PORT\n              valueFrom:\n                secretKeyRef:\n                  name: sing-box-secrets\n                  key: gateway-port\n          volumeMounts:\n            - name: config-template\n              mountPath: /config-template\n            - name: config\n              mountPath: /config\n      containers:\n        - name: sing-box\n          image: ghcr.io/sagernet/sing-box:latest\n          securityContext:\n            allowPrivilegeEscalation: false\n            readOnlyRootFilesystem: true\n            runAsNonRoot: true\n            runAsUser: 1000\n            runAsGroup: 1000\n            capabilities:\n              drop:\n                - ALL\n              add:\n                - NET_BIND_SERVICE\n          args: [\"run\", \"-c\", \"/config/config.json\"]\n          ports:\n            - containerPort: 443\n          volumeMounts:\n            - name: config\n              mountPath: /config\n            - name: tls\n              mountPath: /tls\n              readOnly: true\n      volumes:\n        - name: config-template\n          configMap:\n            name: sing-box-config\n        - name: config\n          emptyDir: {}\n        - name: tls\n          secret:\n            secretName: wg-ildoc-it-tls\n</code></pre> <p>L'initContainer sostituisce i placeholder <code>UUID-CLIENT</code>, <code>GATEWAY-ADDRESS</code> e <code>GATEWAY-PORT</code> con i valori dai secret. Ho impostato <code>revisionHistoryLimit: 3</code> per limitare lo spazio occupato dalle vecchie revisioni.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#5-network-policy-per-isolamento","title":"5. Network Policy per isolamento","text":"<p>Ho aggiunto una Network Policy per limitare il traffico in ingresso e uscita dal pod sing-box:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: sing-box-policy\n  namespace: apps\nspec:\n  podSelector:\n    matchLabels:\n      app: sing-box\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  # Permette solo traffico TCP 443 in ingresso (dal LoadBalancer)\n  - ports:\n    - protocol: TCP\n      port: 443\n  egress:\n  # Permette solo egress UDP verso il gateway WireGuard (UCG) fuori dal cluster\n  # NOTA: La porta deve corrispondere al valore nel secret 'gateway-port' (attualmente 39208)\n  # NOTA: L'IP del gateway \u00e8 nel secret 'gateway-address' (es. 192.168.0.1)\n  # Usa una subnet ristretta che include solo il gateway, oppure specifica l'IP esatto\n  - to:\n    - ipBlock:\n        cidr: 192.168.0.1/32  # IP specifico del gateway UCG - adatta se necessario\n    ports:\n    - protocol: UDP\n      port: 39208\n</code></pre> <p>Questa policy garantisce che il pod sing-box possa:</p> <ul> <li>Ricevere connessioni solo sulla porta 443</li> <li>Comunicare solo con l'UCG sulla porta 51820 UDP (WireGuard)</li> <li>Rispondere ai client</li> <li>Effettuare query DNS</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#6-service","title":"6. Service","text":"<p>Il Service completo \u00e8 disponibile nel repository:</p> <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: sing-box\n  namespace: apps\n  annotations:\n    io.cilium/lb-ipam-ips: \"192.168.0.83\"\nspec:\n  type: LoadBalancer\n  ports:\n    - port: 9443\n      targetPort: 443\n      protocol: TCP\n  selector:\n    app: sing-box\n</code></pre> <p>La porta esposta dal LoadBalancer nel mio caso \u00e8 9443, e ho usato l'annotazione di Cilium per assegnare l'IP statico <code>192.168.0.83</code>.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#deploy-completo","title":"Deploy completo","text":"<p>Nel mio caso uso ArgoCD per il deploy in modalit\u00e0 GitOps, quindi le risorse vengono applicate automaticamente quando committo i file nel repository. I file sono nella cartella <code>kubernetes/applications/sing-box/</code> e vengono gestiti tramite ArgoCD.</p> <p>Per verificare il deployment:</p> <pre><code>kubectl get pods -n apps -l app=sing-box\nkubectl logs -f deployment/sing-box -n apps\nkubectl get svc sing-box -n apps\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#parte-3-configurazione-di-rete","title":"Parte 3 \u2013 Configurazione di rete","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#1-port-forwarding-router-isp","title":"1. Port forwarding Router ISP","text":"<p>Ho configurato il port forwarding sul router ISP:</p> <pre><code>Porta esterna: 443 TCP\nPorta interna: 39300 TCP\nIP destinazione: IP WAN dell'UCG\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#2-port-forwarding-ucg-unifi","title":"2. Port forwarding UCG (UniFi)","text":"<p>Ho configurato il port forwarding via UI UniFi:</p> <ul> <li>Settings \u2192 Internet \u2192 Port Forwarding</li> <li>Creata nuova regola:<ul> <li>Name: <code>sing-box-to-k8s</code></li> <li>Enabled: \u2705</li> <li>From: WAN</li> <li>Port: 39300</li> <li>Protocol: TCP</li> <li>Forward IP: <code>192.168.0.83</code> (IP del LoadBalancer K8s)</li> <li>Forward Port: 9443</li> </ul> </li> </ul> <p>Ho verificato la regola attiva:</p> <pre><code># SSH sull'UCG\niptables-save | grep 39300\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#3-firewall-ucg","title":"3. Firewall UCG","text":"<p>Ho configurato le regole firewall sull'UCG per permettere:</p> <p>Regola 1 - WAN \u2192 K8s (TCP):</p> <ul> <li>Type: LAN In</li> <li>Action: Accept</li> <li>Protocol: TCP</li> <li>Source: WAN</li> <li>Destination: IP LoadBalancer K8s</li> <li>Port: 9443</li> </ul> <p>Regola 2 - K8s \u2192 UCG WireGuard (UDP):</p> <ul> <li>Type: LAN In</li> <li>Action: Accept</li> <li>Protocol: UDP</li> <li>Source: Subnet K8s (192.168.0.0/24 nel mio caso)</li> <li>Destination: IP UCG</li> <li>Port: 51820</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#parte-4-sicurezza-e-hardening","title":"Parte 4 \u2013 Sicurezza e hardening","text":"<p>Esporre la porta 443 su Internet \u00e8 sempre un rischio, soprattutto perch\u00e9 \u00e8 una delle porte pi\u00f9 bersagliate. Ho implementato diverse misure di sicurezza per proteggere il setup.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#1-country-restrictions-sul-gateway","title":"1. Country Restrictions sul gateway","text":"<p>Dato che mi connetto principalmente dall'Italia, ho configurato una whitelist geografica sull'UCG:</p> <p>Settings \u2192 Security \u2192 Protection \u2192 Country Restrictions</p> <p>Ho creato una restriction group che blocca tutti i paesi tranne l'Italia per il traffico inbound. Questo elimina circa l'80% del traffico malevolo automatizzato.</p> <p>Attenzione quando si viaggia</p> <p>Se viaggio all'estero, devo ricordarmi di aggiungere temporaneamente il paese dove mi trovo, altrimenti non riesco a connettermi. Potrei anche disabilitare temporaneamente la restriction.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#2-ipsids-su-unifi-cloud-gateway","title":"2. IPS/IDS su UniFi Cloud Gateway","text":"<p>Ho abilitato l'Intrusion Prevention System sull'UCG:</p> <p>Settings \u2192 Security \u2192 Protection</p> <ul> <li>Attivato Intrusion Prevention (toggle su ON)</li> <li>Selezionate le Active Detections per categoria \"Hacking and Exploits\"</li> <li>Abilitata la categoria Malicious User Agents</li> <li>Scelto livello Balanced (buon compromesso tra sicurezza e performance)</li> </ul> <p>L'IPS analizza il traffico in tempo reale e blocca pattern di attacco noti. L'UCG supporta fino a 1 Gbps con IPS attivo, pi\u00f9 che sufficiente per il mio caso.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#3-crowdsec-su-kubernetes","title":"3. CrowdSec su Kubernetes","text":"<p>Ho deployato CrowdSec come sistema di protezione aggiuntivo. CrowdSec \u00e8 superiore a fail2ban tradizionale perch\u00e9:</p> <ul> <li>\u00c8 progettato nativamente per Kubernetes</li> <li>Usa threat intelligence condivisa da migliaia di utenti</li> <li>Blocca automaticamente IP con comportamenti malevoli</li> <li>Non richiede IP stabili del client</li> </ul> <p>Ho installato CrowdSec tramite ArgoCD usando un chart Helm personalizzato. Il chart \u00e8 nella cartella <code>kubernetes/charts/crowdsec/</code> e viene gestito in modalit\u00e0 GitOps insieme a tutte le altre applicazioni del cluster.</p> <p>ArgoCD monitora il repository e applica automaticamente le modifiche quando committo i file. Il chart \u00e8 basato su quello ufficiale di CrowdSec ma con configurazioni personalizzate per il mio ambiente, incluso l'acquisition dei log del pod sing-box.</p> <p>Poi ho aggiunto un sidecar container al deployment di sing-box per bloccare IP malevoli prima che raggiungano l'applicazione:</p> <pre><code># Aggiunto al deployment sing-box\ncontainers:\n  # ... container sing-box esistente ...\n\n  # Sidecar CrowdSec Firewall Bouncer\n  - name: crowdsec-bouncer\n    image: davidbcn86/crowdsec-firewall-bouncer-docker:latest-nftables\n    securityContext:\n      capabilities:\n        add:\n          - NET_ADMIN\n    env:\n      - name: CROWDSEC_LAPI_URL\n        value: \"http://crowdsec-service.crowdsec.svc.cluster.local:8080\"\n      - name: CROWDSEC_LAPI_KEY\n        valueFrom:\n          secretKeyRef:\n            name: crowdsec-bouncer-key\n            key: api-key\n</code></pre> <p>Il sidecar bouncer intercetta il traffico prima che arrivi a sing-box e droppa le connessioni da IP nella blocklist di CrowdSec.</p> <p>Per generare l'API key del bouncer:</p> <pre><code># Shell nel pod LAPI\nkubectl -n crowdsec exec -it deployment/crowdsec-lapi -- sh\n\n# Genera bouncer key\ncscli bouncers add sing-box-bouncer\n\n# Salvo la key in un Secret\nkubectl create secret generic crowdsec-bouncer-key \\\n  --from-literal=api-key=API-KEY-GENERATA \\\n  --namespace=apps\n</code></pre> <p>Ho anche installato la collezione di scenari HTTP per rilevare pattern di attacco:</p> <pre><code>kubectl -n crowdsec exec -it deployment/crowdsec-lapi -- sh\ncscli collections install crowdsecurity/base-http-scenarios\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#4-security-context-nel-deployment","title":"4. Security Context nel deployment","text":"<p>Ho configurato security context restrittivi per il pod sing-box:</p> <pre><code>spec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    runAsGroup: 1000\n    fsGroup: 1000\n    seccompProfile:\n      type: RuntimeDefault\n\n  containers:\n    - name: sing-box\n      securityContext:\n        allowPrivilegeEscalation: false\n        readOnlyRootFilesystem: true\n        runAsNonRoot: true\n        runAsUser: 1000\n        runAsGroup: 1000\n        capabilities:\n          drop:\n            - ALL\n          add:\n            - NET_BIND_SERVICE  # Solo per bind porta 443\n</code></pre> <p>Questo garantisce che il container:</p> <ul> <li>Non giri come root</li> <li>Non possa escalare privilegi</li> <li>Abbia filesystem read-only</li> <li>Abbia solo la capability minima necessaria</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#5-monitoring-e-alerting","title":"5. Monitoring e alerting","text":"<p>Ho abilitato le notifiche UniFi per eventi di sicurezza:</p> <p>Settings \u2192 Notifications</p> <ul> <li>\u2705 Gateway Events</li> <li>\u2705 IPS/IDS Threats</li> <li>\u2705 Unauthorized Access Attempts</li> </ul> <p>Per monitorare le connessioni attive sulla porta configurata:</p> <pre><code># SSH sull'UCG\nwatch -n 5 'netstat -tn | grep :39300 | wc -l'\n</code></pre> <p>Per vedere i top IP sorgenti:</p> <pre><code>netstat -tn | grep :39300 | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -rn\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#6-protezione-avanzata-ucg","title":"6. Protezione avanzata UCG","text":"<p>Ho abilitato anche le protezioni avanzate disponibili su UniFi:</p> <p>Settings \u2192 Security \u2192 Protection \u2192 Advanced</p> <ul> <li>\u2705 Restrict Access to Malicious IP Addresses: Blocca IP noti per traffico malevolo</li> <li>\u2705 Restrict Access to Tor: Blocca nodi Tor (non mi servono)</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#strategia-di-sicurezza-a-livelli","title":"Strategia di sicurezza a livelli","text":"<p>La mia strategia di protezione funziona su pi\u00f9 livelli:</p> <ol> <li>Country Restrictions \u2192 Prima linea di difesa, blocca ~80% del traffico malevolo</li> <li>IPS/IDS \u2192 Analisi DPI per rilevare attacchi noti</li> <li>CrowdSec \u2192 Blocco automatico IP con comportamenti sospetti</li> <li>Network Policy \u2192 Isolamento del pod sing-box</li> <li>Security Context \u2192 Principio del minimo privilegio</li> </ol> <p>Questo approccio difensivo mi protegge dalla maggior parte degli attacchi automatizzati senza richiedere IP statici o whitelist manuali.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#parte-5-test-end-to-end","title":"Parte 5 \u2013 Test end-to-end","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#1-test-connettivita-base","title":"1. Test connettivit\u00e0 base","text":"<p>Dal client ho testato la raggiungibilit\u00e0 del server:</p> <pre><code>nc -zv vpn.mydomain.it 443\n</code></pre> <p>Output: <code>Connection to vpn.mydomain.it 443 port [tcp/https] succeeded!</code></p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#2-test-tls-e-http2","title":"2. Test TLS e HTTP/2","text":"<pre><code>curl -vk --http2 https://vpn.mydomain.it:443\n</code></pre> <p>Nell'output ho verificato:</p> <ul> <li><code>SSL connection using TLSv1.3</code></li> <li><code>ALPN: server accepted h2</code> (HTTP/2)</li> <li>Certificato valido per <code>vpn.mydomain.it</code></li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#3-test-wireguard","title":"3. Test WireGuard","text":"<p>Sul client:</p> <pre><code>wg show\n</code></pre> <p>Output:</p> <pre><code>interface: wg0\n  public key: ...\n  private key: (hidden)\n  listening port: ...\n\npeer: CHIAVE_PUBBLICA_SERVER\n  endpoint: 127.0.0.1:51820\n  allowed ips: 0.0.0.0/0\n  latest handshake: 10 seconds ago\n  transfer: 5.21 KiB received, 3.14 KiB sent\n  persistent keepalive: every 25 seconds\n</code></pre> <p>Ping test attraverso VPN:</p> <pre><code>ping -c 4 10.20.0.1  # IP del server WireGuard\nping -c 4 8.8.8.8    # Test connettivit\u00e0 generale\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#4-verifica-traffico-mascherato","title":"4. Verifica traffico mascherato","text":"<p>Per verificare il DPI bypass, da una rete restrittiva ho controllato che il traffico sembri HTTPS normale. Il traffico visibile al firewall \u00e8 solo TCP 443 verso vpn.mydomain.it con handshake TLS valido e ALPN HTTP/2.</p> <p>Ho usato tcpdump per confermare che non ci sia traccia di UDP o WireGuard:</p> <pre><code>tcpdump -i eth0 port 443 -nn\n</code></pre> <p>Vedo solo pacchetti TCP con payload criptato TLS.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#5-test-crowdsec","title":"5. Test CrowdSec","text":"<p>Per verificare che CrowdSec funzioni, ho controllato i log:</p> <pre><code>kubectl logs -f -n apps deployment/sing-box -c crowdsec-bouncer\n</code></pre> <p>E ho verificato le decisioni attive:</p> <pre><code>kubectl -n crowdsec exec -it deployment/crowdsec-lapi -- cscli decisions list\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#troubleshooting","title":"Troubleshooting","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#client-beryl-ax","title":"Client (Beryl AX)","text":"<p>Quando sing-box non si avvia, faccio un test manuale:</p> <pre><code># Test manuale\nsing-box run -c /etc/sing-box/config.json\n\n# Verifica JSON\nsing-box check -c /etc/sing-box/config.json\n</code></pre> <p>Se WireGuard non si connette:</p> <pre><code># Verifica che sing-box ascolti\nnetstat -lun | grep 51820\n\n# Test connessione al server\nnc -zv vpn.mydomain.it 443\n\n# Log dettagliati\nlogread -f | grep -E 'sing-box|wireguard'\n</code></pre> <p>Se l'endpoint \u00e8 sbagliato, verifico che il profilo WireGuard \"Office\" usi <code>Endpoint = 127.0.0.1:51820</code>.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#server-kubernetes","title":"Server (Kubernetes)","text":"<p>Se il pod va in crash:</p> <pre><code>kubectl logs -f deployment/sing-box -n apps\nkubectl describe pod -l app=sing-box -n apps\n</code></pre> <p>Errori che ho incontrato:</p> <ul> <li><code>certificate_path</code> o <code>key_path</code> errati</li> <li>UUID non sostituito correttamente</li> <li><code>override_address</code> sintassi deprecata (ho usato <code>action: route-options</code>)</li> </ul> <p>Per verificare il certificato:</p> <pre><code>kubectl get certificate -n apps\nkubectl describe certificate wg-domain-cert -n apps\n</code></pre> <p>Se il LoadBalancer non \u00e8 raggiungibile:</p> <pre><code>kubectl get svc sing-box -n apps\n# Verifico che EXTERNAL-IP sia assegnato\n\n# Test da un pod interno\nkubectl run -it --rm debug --image=nicolaka/netshoot -- bash\nnc -zv IP_LOADBALANCER 9443\n</code></pre> <p>Se il server WireGuard non \u00e8 raggiungibile dal pod:</p> <pre><code># Da un pod di debug\nkubectl run -it --rm debug --image=nicolaka/netshoot -- bash\nnc -zu IP_UCG 51820  # Test UDP\n</code></pre> <p>Se fallisce, verifico routing e firewall.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#crowdsec","title":"CrowdSec","text":"<p>Se CrowdSec non blocca correttamente:</p> <pre><code># Verifica che LAPI sia raggiungibile dal bouncer\nkubectl -n apps exec -it deployment/sing-box -c crowdsec-bouncer -- sh\nwget -O- http://crowdsec-service.crowdsec.svc.cluster.local:8080/health\n\n# Controlla decisioni attive\nkubectl -n crowdsec exec -it deployment/crowdsec-lapi -- cscli decisions list\n\n# Testa manualmente un ban\nkubectl -n crowdsec exec -it deployment/crowdsec-lapi -- cscli decisions add --ip 1.2.3.4 --duration 1h\n</code></pre>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#note-operative-e-best-practices","title":"Note operative e best practices","text":"","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#sicurezza","title":"Sicurezza","text":"<p>Uso un UUID univoco per ogni dispositivo. cert-manager rinnova automaticamente Let's Encrypt ogni 60 giorni. CrowdSec fornisce protezione automatica contro IP malevoli senza bisogno di IP stabili per il client.</p> <p>Dovrei configurare alert pi\u00f9 sofisticati per:</p> <ul> <li>Handshake WireGuard falliti ripetuti</li> <li>Certificati in scadenza</li> <li>Decisioni CrowdSec per IP che tentano attacchi</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#performance","title":"Performance","text":"<p>Il valore <code>1280</code> nel profilo WireGuard tiene conto dell'overhead di gRPC/TLS. sing-box \u00e8 leggero ma l'overhead TLS+gRPC aumenta l'uso CPU del ~10-20%. La latenza \u00e8 aumentata di +5-15ms rispetto a WireGuard diretto a causa dell'incapsulamento. CrowdSec aggiunge un overhead minimo (&lt;1ms) grazie alla sua implementazione efficiente.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#manutenzione","title":"Manutenzione","text":"<p>Per aggiornare sing-box client:</p> <pre><code># Scarico nuova versione\nwget -O /tmp/sing-box.tar.gz URL_NUOVA_VERSIONE\ntar xzf /tmp/sing-box.tar.gz -C /tmp\n/etc/init.d/sing-box stop\nmv /tmp/sing-box*/sing-box /usr/bin/sing-box\n/etc/init.d/sing-box start\n</code></pre> <p>Per aggiornare sing-box server:</p> <pre><code>kubectl rollout restart deployment/sing-box -n apps\n</code></pre> <p>Per aggiornare CrowdSec, modifico il chart nella cartella <code>kubernetes/charts/crowdsec/</code> e committo le modifiche. ArgoCD applica automaticamente gli aggiornamenti quando rileva i cambiamenti nel repository.</p> <p>Per i backup:</p> <ul> <li>Client: <code>/etc/sing-box/config.json</code></li> <li>Kubernetes: Export YAML con <code>kubectl get -o yaml</code></li> <li>CrowdSec decisions: <code>cscli decisions list -o json</code></li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#limitazioni-note","title":"Limitazioni note","text":"<p>Il doppio incapsulamento (WireGuard in gRPC in TLS) riduce leggermente il throughput. Richiede sing-box 1.11.0+ per la nuova sintassi <code>route-options</code>. Il traffico criptato rende difficile il troubleshooting senza accesso ai log.</p> <p>La country restriction blocca le connessioni se viaggio all'estero, quindi devo ricordarmi di aggiungere temporaneamente il paese o disabilitare la restrizione.</p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#conclusione","title":"Conclusione","text":"<p>Questo setup mi permette di:</p> <p>\u2705 Bypassare firewall aziendali che bloccano VPN \u2705 Mascherare completamente WireGuard come HTTPS normale \u2705 Utilizzare certificati TLS validi e standard HTTP/2 \u2705 Mantenere flessibilit\u00e0 con due profili (diretto e mascherato) \u2705 Implementare una soluzione stabile e mantenibile \u2705 Proteggere il servizio esposto con difesa a pi\u00f9 livelli</p> <p>Il traffico risultante \u00e8 indistinguibile da una normale navigazione HTTPS e supera anche i pi\u00f9 sofisticati sistemi DPI. La combinazione di country restrictions, IPS/IDS e CrowdSec fornisce una protezione robusta contro attacchi automatizzati, senza richiedere IP statici del client. Sembra funzionare e per ora sono soddisfatto del risultato. </p>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"blog/2026/01/21/mascherare-wireguard-come-https-con-sing-box-bypassare-firewall-aziendali/#riferimenti","title":"Riferimenti","text":"<ul> <li>sing-box Documentation</li> <li>VLESS Protocol</li> <li>WireGuard Official</li> <li>OpenWrt procd</li> <li>cert-manager</li> <li>CrowdSec Documentation</li> <li>CrowdSec Kubernetes</li> </ul>","tags":["networking","wireguard","kubernetes","vpn","sing-box","security"]},{"location":"kubernetes/argocd/migration/","title":"Guida ArgoCD: Migrazione e Bootstrap","text":""},{"location":"kubernetes/argocd/migration/#parte-1-migrazione-da-installyaml-a-self-management-gitops","title":"Parte 1: Migrazione da install.yaml a Self-Management GitOps","text":""},{"location":"kubernetes/argocd/migration/#prerequisiti","title":"Prerequisiti","text":"<ul> <li>Cluster Kubernetes funzionante con ArgoCD installato via <code>kubectl apply -f install.yaml</code></li> <li>Repository GitOps gi\u00e0 configurato</li> <li>External Secrets Operator funzionante</li> </ul>"},{"location":"kubernetes/argocd/migration/#step-1-preparazione-del-chart-wrapper","title":"Step 1: Preparazione del Chart Wrapper","text":"<p>Creare la struttura del chart wrapper per ArgoCD:</p> <pre><code># Struttura directory\nkubernetes/infra/manifests/argocd/\n\u251c\u2500\u2500 Chart.yaml\n\u251c\u2500\u2500 values.yaml\n\u2514\u2500\u2500 templates/\n    \u2514\u2500\u2500 httproute.yaml\n</code></pre> <p>Chart.yaml: <pre><code>apiVersion: v2\nname: argocd\nversion: 1.0.0\ndependencies:\n  - name: argo-cd\n    version: 8.5.8\n    repository: https://argoproj.github.io/argo-helm\n</code></pre></p> <p>values.yaml: <pre><code>gateway:\n  enabled: true\n  name: cilium-gateway\n  namespace: kube-system\n  hostname: argocd.local.ildoc.it\n\nargo-cd:\n  global:\n    domain: argocd.local.ildoc.it\n\n  redis-ha:\n    enabled: true\n    haproxy:\n      enabled: true\n\n  controller:\n    replicas: 1\n\n  server:\n    replicas: 2\n    ingress:\n      enabled: false\n\n  repoServer:\n    replicas: 2\n\n  applicationSet:\n    replicas: 2\n\n  configs:\n    cm:\n      timeout.reconciliation: 180s\n    params:\n      server.insecure: \"true\"\n</code></pre></p> <p>templates/httproute.yaml: <pre><code>{{- if .Values.gateway.enabled }}\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: argocd-server\n  labels:\n    app.kubernetes.io/name: argocd\n    app.kubernetes.io/instance: {{ .Release.Name }}\nspec:\n  parentRefs:\n  - name: {{ .Values.gateway.name }}\n    namespace: {{ .Values.gateway.namespace }}\n    sectionName: https\n  hostnames:\n  - {{ .Values.gateway.hostname | quote }}\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    backendRefs:\n    - name: argocd-server\n      port: 443\n{{- end }}\n</code></pre></p>"},{"location":"kubernetes/argocd/migration/#step-2-generazione-chartlock","title":"Step 2: Generazione Chart.lock","text":"<pre><code>cd kubernetes/infra/manifests/argocd\nhelm dependency update\ncd -\n\n# Committa Chart.lock (opzionale ma consigliato)\ngit add kubernetes/infra/manifests/argocd/Chart.lock\ngit commit -m \"Add ArgoCD Chart.lock\"\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-3-creazione-application-per-self-management","title":"Step 3: Creazione Application per Self-Management","text":"<p>kubernetes/infra/argocd.yaml: <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: argocd\n  namespace: argocd\n  annotations:\n    argocd.argoproj.io/sync-wave: \"-100\"\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  project: default\n  source:\n    repoURL: https://gitlab.local.ildoc.it/ildoc/homelab.git\n    targetRevision: HEAD\n    path: kubernetes/infra/manifests/argocd\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: argocd\n  syncPolicy:\n    syncOptions:\n      - CreateNamespace=true\n    automated:\n      prune: false  # Importante: non cancellare automaticamente\n      selfHeal: true\n  ignoreDifferences:\n    - group: argoproj.io\n      kind: Application\n      jsonPointers:\n        - /status\n        - /operation\n</code></pre></p>"},{"location":"kubernetes/argocd/migration/#step-4-migrazione-effettiva","title":"Step 4: Migrazione Effettiva","text":"<pre><code># 1. Rimuovi finalizers dalle Applications per evitare blocchi\nkubectl get applications -n argocd -o name | while read app; do\n  kubectl patch $app -n argocd -p '{\"metadata\":{\"finalizers\":[]}}' --type=merge\ndone\n\n# 2. Rimuovi vecchia installazione\nkubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/ha/install.yaml\n\n# 3. Attendi che il namespace sia pulito\nkubectl get namespace argocd -w  # Aspetta che termini la cancellazione\n\n# 4. Installa con Helm (saltando le CRD gi\u00e0 esistenti)\nhelm install argocd ./kubernetes/infra/manifests/argocd \\\n  -n argocd \\\n  --create-namespace \\\n  --skip-crds\n\n# 5. Verifica installazione\nkubectl get pods -n argocd -w\n\n# 6. Applica l'Application per self-management\nkubectl apply -f kubernetes/infra/argocd.yaml\n\n# 7. Verifica che ArgoCD gestisca se stesso\nkubectl get application argocd -n argocd\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-5-verifica-e-test","title":"Step 5: Verifica e Test","text":"<pre><code># Verifica che l'Application sia sincronizzata\nargocd app get argocd\n\n# Test di modifica: cambia un valore nel values.yaml\nvim kubernetes/infra/manifests/argocd/values.yaml\n# Cambia ad esempio: timeout.reconciliation: 180s \u2192 300s\n\ngit add kubernetes/infra/manifests/argocd/values.yaml\ngit commit -m \"Test self-management: update timeout\"\ngit push\n\n# Verifica che ArgoCD applichi automaticamente il cambiamento\nkubectl get configmap argocd-cm -n argocd -o yaml | grep reconciliation\n</code></pre>"},{"location":"kubernetes/argocd/migration/#parte-2-prima-installazione-di-un-nuovo-cluster","title":"Parte 2: Prima Installazione di un Nuovo Cluster","text":""},{"location":"kubernetes/argocd/migration/#step-1-installazione-iniziale-di-argocd","title":"Step 1: Installazione Iniziale di ArgoCD","text":"<pre><code># 1. Clona il repository GitOps\ngit clone https://gitlab.local.ildoc.it/ildoc/homelab.git\ncd homelab\n\n# 2. Installa ArgoCD con Helm\ncd kubernetes/infra/manifests/argocd\n\n# Genera Chart.lock (se non committato)\nhelm dependency update\n\n# Installa ArgoCD\nhelm install argocd . \\\n  -n argocd \\\n  --create-namespace \\\n  --skip-crds  # Le CRD sono gi\u00e0 nel manifest HA\n\ncd -\n\n# 3. Attendi che tutti i pod siano pronti\nkubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-2-configurazione-accesso-opzionale","title":"Step 2: Configurazione Accesso (Opzionale)","text":"<pre><code># Ottieni la password admin di default\nkubectl -n argocd get secret argocd-initial-admin-secret \\\n  -o jsonpath=\"{.data.password}\" | base64 -d\n\n# Login tramite CLI (opzionale)\nargocd login argocd.local.ildoc.it --username admin\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-3-configurazione-repository-ssh-se-privato","title":"Step 3: Configurazione Repository SSH (se privato)","text":"<pre><code># 1. Genera SSH key per ArgoCD\nssh-keygen -t ed25519 \\\n  -C \"argocd@local.ildoc.it\" \\\n  -f ~/.ssh/argocd_gitlab \\\n  -N \"\"\n\n# 2. Aggiungi la chiave pubblica a GitLab\ncat ~/.ssh/argocd_gitlab.pub\n# Copia e incolla in GitLab \u2192 Settings \u2192 Repository \u2192 Deploy Keys\n\n# 3. Salva la chiave privata in Vault\nvault kv put kubernetes/argocd \\\n  gitlab-ssh-key=@~/.ssh/argocd_gitlab\n\n# 4. Ottieni l'host key di GitLab\nssh-keyscan gitlab.local.ildoc.it\n\n# 5. Aggiungi le known hosts al values.yaml\nvim kubernetes/infra/manifests/argocd/values.yaml\n</code></pre> <p>Aggiungere: <pre><code>argo-cd:\n  configs:\n    ssh:\n      knownHosts: |\n        gitlab.local.ildoc.it ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA...\n</code></pre></p> <pre><code># 6. Upgrade ArgoCD con la nuova configurazione\nhelm upgrade argocd kubernetes/infra/manifests/argocd \\\n  -n argocd\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-4-creazione-externalsecret-per-repository","title":"Step 4: Creazione ExternalSecret per Repository","text":"<p>kubernetes/infra/manifests/infra-secrets/argocd-repo-ssh.yaml: <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: argocd-repo-ssh\n  namespace: argocd\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: vault-kubernetes-secret-store\n    kind: ClusterSecretStore\n  target:\n    name: repo-homelab-ssh\n    creationPolicy: Owner\n    template:\n      metadata:\n        labels:\n          argocd.argoproj.io/secret-type: repository\n      data:\n        type: git\n        url: git@gitlab.local.ildoc.it:ildoc/homelab.git\n        sshPrivateKey: \"{{ .sshKey }}\"\n  data:\n    - secretKey: sshKey\n      remoteRef:\n        key: kubernetes/data/argocd\n        property: gitlab-ssh-key\n</code></pre></p>"},{"location":"kubernetes/argocd/migration/#step-5-bootstrap-del-sistema-gitops","title":"Step 5: Bootstrap del Sistema GitOps","text":"<pre><code># 1. Applica l'Application root (app-of-apps)\nkubectl apply -f kubernetes/root-applications.yaml\n\n# 2. Verifica che la root Application sia stata creata\nkubectl get application root -n argocd\n\n# 3. La root Application creer\u00e0 automaticamente tutte le altre\nkubectl get applications -n argocd -w\n\n# Output atteso:\n# NAME              SYNC STATUS   HEALTH STATUS\n# root              Synced        Healthy\n# infra             Synced        Healthy\n# argocd            OutOfSync     Healthy  &lt;- Normale, ancora manuale\n# cert-manager      Synced        Healthy\n# cilium            Synced        Healthy\n# ...\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-6-adozione-self-management-di-argocd","title":"Step 6: Adozione Self-Management di ArgoCD","text":"<pre><code># 1. Applica l'Application per ArgoCD stesso\nkubectl apply -f kubernetes/infra/argocd.yaml\n\n# 2. Verifica lo stato\nkubectl get application argocd -n argocd\n\n# 3. Forza il primo sync (pu\u00f2 essere OutOfSync)\nargocd app sync argocd\n\n# 4. Da ora in poi, ArgoCD gestisce se stesso!\n# Ogni modifica a values.yaml viene applicata automaticamente\n</code></pre>"},{"location":"kubernetes/argocd/migration/#step-7-verifica-finale","title":"Step 7: Verifica Finale","text":"<pre><code># 1. Controlla tutte le Applications\nkubectl get applications -n argocd\n\n# 2. Verifica la salute di ArgoCD\nkubectl get pods -n argocd\n\n# 3. Test self-management\n# Modifica qualcosa nel values.yaml di ArgoCD\nvim kubernetes/infra/manifests/argocd/values.yaml\ngit add . &amp;&amp; git commit -m \"Test\" &amp;&amp; git push\n\n# 4. Osserva ArgoCD applicare la modifica automaticamente\nkubectl get application argocd -n argocd -w\n</code></pre>"},{"location":"kubernetes/argocd/migration/#ordine-di-deploy-consigliato","title":"Ordine di Deploy Consigliato","text":"<p>Grazie alle sync-waves, l'ordine \u00e8 automatico: 1. Wave -100: Cilium, External Secrets CRDs 2. Wave -99: NFS CSI, Metrics Server 3. Wave -98: Cert-Manager, External Secrets Operator 4. Wave -90: Certificates 5. Wave -85: Prometheus Stack 6. Wave -80: Infra Secrets 7. Wave -79: Ingresses 8. Wave -75: GitLab Runner 9. Wave -70: Rancher 10. Wave -60: Authentik 11. Altre applicazioni</p>"},{"location":"kubernetes/argocd/migration/#note-importanti","title":"Note Importanti","text":""},{"location":"kubernetes/argocd/migration/#gestione-degli-aggiornamenti","title":"Gestione degli Aggiornamenti","text":"<p>Per aggiornare ArgoCD: <pre><code># 1. Modifica Chart.yaml\nvim kubernetes/infra/manifests/argocd/Chart.yaml\n# version: 8.5.8 \u2192 8.6.0\n\n# 2. Aggiorna dipendenze\ncd kubernetes/infra/manifests/argocd\nhelm dependency update\n\n# 3. Committa\ngit add Chart.yaml Chart.lock\ngit commit -m \"Update ArgoCD to 8.6.0\"\ngit push\n\n# 4. ArgoCD si aggiorna automaticamente!\n</code></pre></p>"},{"location":"kubernetes/argocd/migration/#troubleshooting-comune","title":"Troubleshooting Comune","text":"<p>Application OutOfSync permanente: <pre><code># Verifica ignoreDifferences\nkubectl describe application argocd -n argocd\n\n# Forza sync\nargocd app sync argocd --force\n</code></pre></p> <p>Repository connection failed: <pre><code># Verifica il secret\nkubectl get secret -n argocd -l argocd.argoproj.io/secret-type=repository\n\n# Test connessione\nkubectl exec -n argocd deployment/argocd-repo-server -- \\\n  ssh -T git@gitlab.local.ildoc.it\n</code></pre></p> <p>Namespace bloccato in Terminating: <pre><code># Rimuovi finalizers\nkubectl get applications -n argocd -o name | while read app; do\n  kubectl patch $app -n argocd -p '{\"metadata\":{\"finalizers\":null}}' --type=merge\ndone\n</code></pre></p>"},{"location":"kubernetes/argocd/migration/#backup-e-disaster-recovery","title":"Backup e Disaster Recovery","text":"<p>In caso di disaster, il ripristino \u00e8 semplice: <pre><code># 1. Reinstalla ArgoCD con Helm\nhelm install argocd ./kubernetes/infra/manifests/argocd -n argocd\n\n# 2. Applica root-applications.yaml\nkubectl apply -f kubernetes/root-applications.yaml\n\n# 3. Tutto si ricrea automaticamente da Git!\n</code></pre></p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/","title":"Configurazione Authentik come OIDC Provider per Matrix","text":""},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-1-configurazione-authentik-web-ui","title":"Fase 1: Configurazione Authentik (Web UI)","text":""},{"location":"kubernetes/authentik/authentik_matrix_oidc/#11-crea-un-oauth2oidc-provider","title":"1.1 Crea un OAuth2/OIDC Provider","text":"<ol> <li>Accedi ad Authentik: <code>https://auth.ildoc.it</code></li> <li>Vai su Applications \u2192 Providers</li> <li>Click su Create</li> <li>Seleziona OAuth2/OpenID Provider</li> </ol> <p>Configurazione del Provider: - Name: <code>Matrix Synapse</code> - Authorization flow: <code>default-provider-authorization-implicit-consent</code> (o quello che preferisci) - Client type: <code>Confidential</code> - Client ID: <code>matrix-synapse</code> (puoi personalizzarlo) - Client Secret: Copia questo valore! Lo useremo dopo in Vault - Redirect URIs/Origins (RegEx):   <pre><code>https://matrix\\.ildoc\\.it/_synapse/client/oidc/callback\n</code></pre> - Signing Key: <code>authentik Self-signed Certificate</code> (o il tuo certificato)</p> <p>Configurazioni avanzate (clicca \"Advanced protocol settings\"): - Scopes:    - <code>openid</code> \u2713   - <code>email</code> \u2713   - <code>profile</code> \u2713 - Subject mode: <code>Based on the User's UUID</code> - Include claims in id_token: \u2713 (abilitato)</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#12-crea-lapplication","title":"1.2 Crea l'Application","text":"<ol> <li>Vai su Applications \u2192 Applications</li> <li>Click su Create</li> </ol> <p>Configurazione: - Name: <code>Matrix</code> - Slug: <code>matrix</code> - Provider: Seleziona il provider <code>Matrix Synapse</code> creato prima - Launch URL: <code>https://element.ildoc.it</code> (opzionale) - Policy engine mode: <code>any</code> (o configura policy specifiche)</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#13-opzionale-crea-un-gruppo-per-utenti-matrix","title":"1.3 (Opzionale) Crea un gruppo per utenti Matrix","text":"<ol> <li>Vai su Directory \u2192 Groups</li> <li>Crea un gruppo chiamato <code>matrix-users</code></li> <li>Assegna gli utenti che devono accedere a Matrix</li> </ol> <p>Poi nella Application, configura le policy per permettere solo a questo gruppo l'accesso.</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-2-salva-il-client-secret-in-vault","title":"Fase 2: Salva il Client Secret in Vault","text":"<pre><code># Salva il client secret che hai copiato da Authentik\nvault kv put kubernetes/data/apps/matrix \\\n  oidc_client_secret=\"&lt;IL_CLIENT_SECRET_DA_AUTHENTIK&gt;\"\n\n# Verifica\nvault kv get kubernetes/data/apps/matrix\n</code></pre>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-3-aggiorna-matrix-configmap","title":"Fase 3: Aggiorna Matrix ConfigMap","text":"<p>Aggiungi la configurazione OIDC a <code>homeserver.yaml</code> nella ConfigMap di Matrix.</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-4-aggiorna-matrix-deployment","title":"Fase 4: Aggiorna Matrix Deployment","text":"<p>Aggiungi l'environment variable per il client secret.</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-5-aggiorna-lexternal-secret","title":"Fase 5: Aggiorna l'External Secret","text":"<p>Aggiungi il client secret ai secret di Matrix.</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#fase-6-test-del-flusso-oidc","title":"Fase 6: Test del flusso OIDC","text":""},{"location":"kubernetes/authentik/authentik_matrix_oidc/#test-via-element-web","title":"Test via Element Web","text":"<ol> <li>Vai su <code>https://element.ildoc.it</code></li> <li>Clicca su \"Sign in\"</li> <li>Dovresti vedere un pulsante \"Continue with Authentik\" (o simile)</li> <li>Click \u2192 redirect ad Authentik</li> <li>Login con le tue credenziali Authentik</li> <li>Consent screen (se necessario)</li> <li>Redirect a Element, ora sei autenticato!</li> </ol>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#test-via-curl-per-debug","title":"Test via curl (per debug)","text":"<pre><code># 1. Discovery endpoint\ncurl https://auth.ildoc.it/application/o/matrix-synapse/.well-known/openid-configuration | jq\n\n# 2. Verifica che Matrix veda la configurazione OIDC\nkubectl exec -n apps deploy/matrix-synapse -- \\\n  grep -A 20 \"oidc_providers\" /data/homeserver.yaml\n\n# 3. Controlla i logs di Matrix durante il login\nkubectl logs -n apps -l app=matrix-synapse -f | grep -i oidc\n</code></pre>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kubernetes/authentik/authentik_matrix_oidc/#errore-redirect_uri-mismatch","title":"Errore \"redirect_uri mismatch\"","text":"<p>Verifica che l'URI in Authentik sia esattamente: <pre><code>https://matrix\\.ildoc\\.it/_synapse/client/oidc/callback\n</code></pre></p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#utente-non-viene-creato-automaticamente","title":"Utente non viene creato automaticamente","text":"<p>Controlla i mapping in Authentik e assicurati che <code>allow_existing_users</code> sia true.</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#errore-issuer-mismatch","title":"Errore \"issuer mismatch\"","text":"<p>Verifica che <code>issuer</code> nella configurazione Matrix corrisponda esattamente all'URL di Authentik (con trailing slash).</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#voglio-vedere-gli-attributi-che-authentik-passa-a-matrix","title":"Voglio vedere gli attributi che Authentik passa a Matrix","text":"<pre><code># Abilita debug logging in Matrix\nkubectl exec -n apps deploy/matrix-synapse -- \\\n  sed -i 's/level: INFO/level: DEBUG/' /data/log.config\n\n# Restart del pod\nkubectl rollout restart -n apps deploy/matrix-synapse\n\n# Guarda i log\nkubectl logs -n apps -l app=matrix-synapse -f | grep -i \"oidc\\|userinfo\"\n</code></pre>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#attributi-mappati","title":"Attributi mappati","text":"<p>Con questa configurazione, Authentik passer\u00e0 a Matrix:</p> Attributo Authentik Claim OIDC Uso in Matrix <code>username</code> <code>preferred_username</code> Matrix User ID <code>email</code> <code>email</code> Email utente <code>name</code> <code>name</code> Display name <code>UUID</code> <code>sub</code> Subject ID (univoco)"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#gestione-utenti","title":"Gestione utenti","text":""},{"location":"kubernetes/authentik/authentik_matrix_oidc/#utenti-esistenti","title":"Utenti esistenti","text":"<p>Se hai gi\u00e0 utenti in Matrix con password locale, e vuoi permettere loro di usare OIDC: - Imposta <code>allow_existing_users: true</code> - L'utente deve avere lo stesso <code>localpart</code> (parte prima di <code>:matrix.ildoc.it</code>)</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#solo-oidc-consigliato","title":"Solo OIDC (consigliato)","text":"<p>Per forzare OIDC e disabilitare completamente la registrazione locale:</p> <pre><code>enable_registration: false\npassword_config:\n  enabled: false  # Disabilita completamente le password\n</code></pre>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#mapping-username","title":"Mapping username","text":"<p>Matrix userID = <code>@&lt;preferred_username&gt;:matrix.ildoc.it</code></p> <p>Assicurati che gli username in Authentik siano: - Minuscoli - Senza spazi - Senza caratteri speciali (solo lettere, numeri, <code>_</code>, <code>-</code>, <code>.</code>)</p>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#flusso-di-autenticazione-completo","title":"Flusso di autenticazione completo","text":"<pre><code>1. Utente visita Element Web\n2. Click \"Sign in with Authentik\"\n3. \u2192 Redirect a https://auth.ildoc.it/application/o/authorize/\n4. Authentik: login + consent\n5. \u2192 Redirect a https://matrix.ildoc.it/_synapse/client/oidc/callback?code=...\n6. Matrix scambia code con access token\n7. Matrix chiama userinfo endpoint di Authentik\n8. Matrix crea/aggiorna utente locale\n9. Matrix genera access token per Element\n10. Element \u00e8 autenticato!\n</code></pre>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#best-practices","title":"Best Practices","text":"<ol> <li>Usa gruppi Authentik per controllare chi pu\u00f2 accedere a Matrix</li> <li>Abilita MFA in Authentik per maggiore sicurezza</li> <li>Monitora i log durante i primi test</li> <li>Backup della configurazione prima di modificare</li> <li>Testa con un utente di test prima di rollout completo</li> </ol>"},{"location":"kubernetes/authentik/authentik_matrix_oidc/#next-steps","title":"Next Steps","text":"<p>Una volta funzionante: - Configura policy di accesso in Authentik - Abilita MFA per utenti Matrix - Configura email notifications da Authentik - Considera federation con altri server Matrix (se necessario)</p>"},{"location":"kubernetes/monitoring/claude/","title":"Claude","text":"<p>Perfetto! Hai ragione su entrambi i fronti. Facciamo un setup pulito e dichiarativo.</p>"},{"location":"kubernetes/monitoring/claude/#manifest-necessari-per-il-tuo-setup","title":"\ud83d\udcc1 Manifest necessari per il tuo setup","text":""},{"location":"kubernetes/monitoring/claude/#struttura-file-da-creare","title":"Struttura file da creare:","text":"<pre><code>kubernetes/\n\u251c\u2500\u2500 infra/\n\u2502   \u251c\u2500\u2500 prometheus-stack.yaml                    # ArgoCD Application\n\u2502   \u2514\u2500\u2500 manifests/\n\u2502       \u2514\u2500\u2500 prometheus-stack/\n\u2502           \u251c\u2500\u2500 Chart.yaml                       # Helm chart definition\n\u2502           \u251c\u2500\u2500 values.yaml                       # Configurazione principale\n\u2502           \u2514\u2500\u2500 templates/\n\u2502               \u251c\u2500\u2500 httproutes.yaml               # Routes per Grafana/Prometheus/AlertManager\n\u2502               \u251c\u2500\u2500 pve-exporter.yaml             # Proxmox exporter deployment\n\u2502               \u2514\u2500\u2500 monitoring-targets.yaml       # ServiceMonitors e Probes\n</code></pre>"},{"location":"kubernetes/monitoring/claude/#i-manifest-essenziali-step-da-eseguire","title":"\ud83d\udcdd I Manifest essenziali:## \ud83d\ude80 Step da eseguire:","text":""},{"location":"kubernetes/monitoring/claude/#1-prepara-proxmox-5-minuti","title":"1. Prepara Proxmox (5 minuti)","text":"<pre><code># Sul tuo Proxmox, crea un utente read-only per il monitoring\npveum user add monitoring@pve --comment \"Prometheus monitoring\"\npveum passwd monitoring@pve  # Setta la password\npveum aclmod / -user monitoring@pve -role PVEAuditor\n</code></pre>"},{"location":"kubernetes/monitoring/claude/#2-configura-gitlab-5-minuti","title":"2. Configura GitLab (5 minuti)","text":"<pre><code># Verifica che i exporter siano abilitati in /etc/gitlab/gitlab.rb\ngitlab_exporter['enable'] = true\nprometheus['enable'] = true\nnode_exporter['enable'] = true\nredis_exporter['enable'] = true\npostgres_exporter['enable'] = true\ngitlab_monitor['enable'] = true\n\n# Riconfigura GitLab\nsudo gitlab-ctl reconfigure\n</code></pre>"},{"location":"kubernetes/monitoring/claude/#3-crea-i-file-nel-repo-10-minuti","title":"3. Crea i file nel repo (10 minuti)","text":"<pre><code># Crea la struttura\nmkdir -p kubernetes/infra/manifests/prometheus-stack/templates\n\n# Copia i manifest nelle posizioni corrette\n# - prometheus-stack.yaml in kubernetes/infra/\n# - Chart.yaml in kubernetes/infra/manifests/prometheus-stack/\n# - values.yaml in kubernetes/infra/manifests/prometheus-stack/\n# - *.yaml in kubernetes/infra/manifests/prometheus-stack/templates/\n</code></pre>"},{"location":"kubernetes/monitoring/claude/#4-personalizza-le-configurazioni","title":"4. Personalizza le configurazioni","text":"<p>Modifica nei file: - Password Grafana in <code>values.yaml</code> - Credenziali Proxmox in <code>pve-exporter.yaml</code> - Token Telegram in <code>values.yaml</code> (se vuoi gli alert) - IP dei nodi Proxmox in <code>pve-exporter.yaml</code></p>"},{"location":"kubernetes/monitoring/claude/#5-commit-e-deploy","title":"5. Commit e deploy","text":"<pre><code>git add kubernetes/infra/prometheus-stack.yaml\ngit add kubernetes/infra/manifests/prometheus-stack/\ngit commit -m \"Add Prometheus monitoring stack with GitLab and Proxmox\"\ngit push\n</code></pre>"},{"location":"kubernetes/monitoring/claude/#6-argocd-fara-il-deploy-automatico","title":"6. ArgoCD far\u00e0 il deploy automatico","text":"<p>Dopo qualche minuto avrai: - \ud83d\udcca Grafana: https://grafana.local.ildoc.it - \ud83d\udcc8 Prometheus: https://prometheus.local.ildoc.it - \ud83d\udd14 AlertManager: https://alertmanager.local.ildoc.it</p>"},{"location":"kubernetes/monitoring/claude/#cosa-avrai","title":"\u2705 Cosa avrai:","text":"<ol> <li>Monitoring completo dichiarativo (tutto in Git)</li> <li>GitLab monitorato con tutte le metriche native</li> <li>Proxmox cluster con metriche di VM, container, storage</li> <li>HTTP Probes per tutti i servizi (sostituisce Uptime Kuma)</li> <li>Dashboard Grafana pre-configurate</li> <li>Alert configurabili via YAML</li> </ol>"},{"location":"kubernetes/monitoring/claude/#pro-di-questo-approccio","title":"\ud83c\udfaf Pro di questo approccio:","text":"<ul> <li>\u2705 100% GitOps - tutto versionato e dichiarativo</li> <li>\u2705 No agent da installare - GitLab e Proxmox hanno gi\u00e0 tutto</li> <li>\u2705 Probes dichiarativi - aggiungi/rimuovi target via Git</li> <li>\u2705 Storia metriche - 30 giorni di retention</li> <li>\u2705 Alert intelligenti - basati su metriche, non solo up/down</li> </ul> <p>Puoi tenere Uptime Kuma per la status page pubblica, ma ora hai il monitoring serio sotto! \ud83d\ude80</p>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/archive/2025/","title":"2025","text":""}]}